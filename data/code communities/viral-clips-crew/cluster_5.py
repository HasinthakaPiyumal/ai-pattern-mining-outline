# Cluster 5

def main(extracts):
    os.makedirs('crew_output', exist_ok=True)
    subtitles = get_subtitles()
    if subtitles is None:
        logging.error('Failed to read subtitles. Exiting.')
        return
    subtitler_agent_1 = Agent(role=dedent(f'\n            Segment 1 Subtitler\n            '), backstory=dedent(f'\n            Experienced subtitler who writes captions or subtitles that accurately represent the audio, including dialogue, sound effects, and music. The subtitles need to be properly timed with the video using correct time codes.\n            '), goal=dedent(f'\n            Match a list of extracts from a video clip with the corresponding timed subtitles. Given the segments found by the Digital Producer, find the segment timings within the `.srt` file and return each segment as an `.srt` subtitle segment.\n            '), allow_delegation=False, verbose=True, max_iter=1, max_rpm=1, llm=ChatGoogleGenerativeAI(model='gemini-1.5-pro-exp-0801', verbose=True, temperature=0.0, google_api_key=gemini_api_key))
    subtitler_agent_2 = Agent(role=dedent(f'\n            Segment 2 Subtitler\n            '), backstory=dedent(f'\n            Experienced subtitler who writes captions or subtitles that accurately represent the audio, including dialogue, sound effects, and music. The subtitles need to be properly timed with the video using correct time codes.\n            '), goal=dedent(f'\n            Match a list of extracts from a video clip with the corresponding timed subtitles. Given the segments found by the Digital Producer, find the segment timings within the `.srt` file and return each segment as an `.srt` subtitle segment.\n            '), allow_delegation=False, verbose=True, max_iter=1, max_rpm=1, llm=ChatGoogleGenerativeAI(model='gemini-1.5-pro-exp-0801', verbose=True, temperature=0.0, google_api_key=gemini_api_key))
    subtitler_agent_3 = Agent(role=dedent(f'\n            Segment 3 Subtitler\n            '), backstory=dedent(f'\n            Experienced subtitler who writes captions or subtitles that accurately represent the audio, including dialogue, sound effects, and music. The subtitles need to be properly timed with the video using correct time codes.\n            '), goal=dedent(f'\n            Match a list of extracts from a video clip with the corresponding timed subtitles. Given the segments found by the Digital Producer, find the segment timings within the `.srt` file and return each segment as an `.srt` subtitle segment.\n            '), allow_delegation=False, verbose=True, max_iter=1, max_rpm=1, llm=ChatGoogleGenerativeAI(model='gemini-1.5-pro-exp-0801', verbose=True, temperature=0.0, google_api_key=gemini_api_key))
    return_subtitles_1 = Task(description=dedent(f"\n            You will be provided with a transcription extract from a video clip and the full content of an .srt subtitle file corresponding to that clip. Your task is to match the transcription extract to the subtitle segment it best aligns with and return the results in a specific format.\n        \n            Here is the transcription extract:\n            <segments>\n            {extracts[0]}\n            </segments>\n        \n            Here is the full content of the .srt subtitle file:\n            <srt_file>\n            {subtitles}\n            </srt_file>\n        \n            Please follow these steps:\n            1. Carefully read through the transcription excerpt within the <segments> tags.\n            2. Given the extract, search through the <srt_file> content to find the subtitle segment that best matches the extract. To determine the best match, look for segments that contain the most overlapping words or phrases with the extract.\n            3. Once you've found the best matching subtitle segment for the excerpt, format the match as follows:\n            [segment number]\n            [start time] --> [end time] \n            [matched transcription extract]\n            5. After processing the extract, combine the formatted matches into a single block of text. This should resemble a valid .srt subtitle file, with each match separated by a blank line.\n        \n            Please note: .srt files have a specific format that must be followed exactly in order for them to be readable. Therefore, it is crucial that you do not include any extra content beyond the raw subtitle data itself. This means:\n            - No comments explaining your work\n            - No notes about which extracts matched which segments\n            - No additional text that isn't part of the subtitle segments\n        \n            Simply return the matches, properly formatted, as the entire contents of your response.\n            "), expected_output=dedent(f"""\n            Format each match exactly as follows, and include only these details:\n        \n            [segment number]\n            [start time] --> [end time]\n            [matched transcription extract]\n        \n            Compile all the matches and return them without any additional text or commentary.\n        \n            Example of the expected output:\n        \n            26\n            00:01:57,000 --> 00:02:00,400\n            Sight turned into insight.\n            \n            27\n            00:02:00,400 --> 00:02:03,240\n            Seeing became understanding.\n            \n            28\n            00:02:03,240 --> 00:02:05,680\n            Understanding led to actions,\n\n        \n            Please note: .srt files have a specific format that must be followed exactly in order for them to be readable. Therefore, it is crucial that you DO NOT INCLUDE any extra content beyond the raw subtitle data itself. This means:\n            - No comments explaining your work\n            - No comments introducing your work\n            - No comments ending your work\n            - No notes about which extracts matched which segments\n            - No additional text that isn't part of the subtitle segments\n            - No comments like: "Here is the output with the matched segments in the requested format:"\n            """), agent=subtitler_agent_1, output_file=f'crew_output/new_file_return_subtitles_1_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.srt')
    return_subtitles_2 = Task(description=dedent(f"\n            You will be provided with a transcription extract from a video clip and the full content of an .srt subtitle file corresponding to that clip. Your task is to match the transcription extract to the subtitle segment it best aligns with and return the results in a specific format.\n\n            Here is the transcription extract:\n            <segments>\n            {extracts[1]}\n            </segments>\n\n            Here is the full content of the .srt subtitle file:\n            <srt_file>\n            {subtitles}\n            </srt_file>\n\n            Please follow these steps:\n            1. Carefully read through the transcription excerpt within the <segments> tags.\n            2. Given the extract, search through the <srt_file> content to find the subtitle segment that best matches the extract. To determine the best match, look for segments that contain the most overlapping words or phrases with the extract.\n            3. Once you've found the best matching subtitle segment for the excerpt, format the match as follows:\n            [segment number]\n            [start time] --> [end time] \n            [matched transcription extract]\n            5. After processing the extract, combine the formatted matches into a single block of text. This should resemble a valid .srt subtitle file, with each match separated by a blank line.\n\n            Please note: .srt files have a specific format that must be followed exactly in order for them to be readable. Therefore, it is crucial that you do not include any extra content beyond the raw subtitle data itself. This means:\n            - No comments explaining your work\n            - No notes about which extracts matched which segments\n            - No additional text that isn't part of the subtitle segments\n\n            Simply return the matches, properly formatted, as the entire contents of your response.\n            "), expected_output=dedent(f"""\n            Format each match exactly as follows, and include only these details:\n\n            [segment number]\n            [start time] --> [end time]\n            [matched transcription extract]\n\n            Compile all the matches and return them without any additional text or commentary.\n\n            Example of the expected output:\n\n            26\n            00:01:57,000 --> 00:02:00,400\n            Sight turned into insight.\n\n            27\n            00:02:00,400 --> 00:02:03,240\n            Seeing became understanding.\n\n            28\n            00:02:03,240 --> 00:02:05,680\n            Understanding led to actions,\n\n\n            Please note: .srt files have a specific format that must be followed exactly in order for them to be readable. Therefore, it is crucial that you DO NOT INCLUDE any extra content beyond the raw subtitle data itself. This means:\n            - No comments explaining your work\n            - No comments introducing your work\n            - No comments ending your work\n            - No notes about which extracts matched which segments\n            - No additional text that isn't part of the subtitle segments\n            - No comments like: "Here is the output with the matched segments in the requested format:"\n            """), agent=subtitler_agent_2, output_file=f'crew_output/new_file_return_subtitles_2_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.srt')
    return_subtitles_3 = Task(description=dedent(f"\n            You will be provided with a transcription extract from a video clip and the full content of an .srt subtitle file corresponding to that clip. Your task is to match the transcription extract to the subtitle segment it best aligns with and return the results in a specific format.\n\n            Here is the transcription extract:\n            <segments>\n            {extracts[2]}\n            </segments>\n\n            Here is the full content of the .srt subtitle file:\n            <srt_file>\n            {subtitles}\n            </srt_file>\n\n            Please follow these steps:\n            1. Carefully read through the transcription excerpt within the <segments> tags.\n            2. Given the extract, search through the <srt_file> content to find the subtitle segment that best matches the extract. To determine the best match, look for segments that contain the most overlapping words or phrases with the extract.\n            3. Once you've found the best matching subtitle segment for the excerpt, format the match as follows:\n            [segment number]\n            [start time] --> [end time] \n            [matched transcription extract]\n            5. After processing the extract, combine the formatted matches into a single block of text. This should resemble a valid .srt subtitle file, with each match separated by a blank line.\n\n            Please note: .srt files have a specific format that must be followed exactly in order for them to be readable. Therefore, it is crucial that you do not include any extra content beyond the raw subtitle data itself. This means:\n            - No comments explaining your work\n            - No notes about which extracts matched which segments\n            - No additional text that isn't part of the subtitle segments\n\n            Simply return the matches, properly formatted, as the entire contents of your response.\n            "), expected_output=dedent(f"""\n            Format each match exactly as follows, and include only these details:\n\n            [segment number]\n            [start time] --> [end time]\n            [matched transcription extract]\n\n            Compile all the matches and return them without any additional text or commentary.\n\n            Example of the expected output:\n\n            26\n            00:01:57,000 --> 00:02:00,400\n            Sight turned into insight.\n\n            27\n            00:02:00,400 --> 00:02:03,240\n            Seeing became understanding.\n\n            28\n            00:02:03,240 --> 00:02:05,680\n            Understanding led to actions,\n\n\n            Please note: .srt files have a specific format that must be followed exactly in order for them to be readable. Therefore, it is crucial that you DO NOT INCLUDE any extra content beyond the raw subtitle data itself. This means:\n            - No comments explaining your work\n            - No comments introducing your work\n            - No comments ending your work\n            - No notes about which extracts matched which segments\n            - No additional text that isn't part of the subtitle segments\n            - No comments like: "Here is the output with the matched segments in the requested format:"\n            """), agent=subtitler_agent_3, output_file=f'crew_output/new_file_return_subtitles_3_{datetime.now().strftime('%Y%m%d_%H%M%S_%f')}.srt')
    crew = Crew(agents=[subtitler_agent_1, subtitler_agent_2, subtitler_agent_3], tasks=[return_subtitles_1, return_subtitles_2, return_subtitles_3], verbose=2, process=Process.sequential)
    result = crew.kickoff()
    logging.info(dedent(f'\n\n########################'))
    logging.info(dedent(f'## Here is your custom crew run result:'))
    logging.info(dedent(f'########################\n'))
    logging.info(result)
    return result

def get_subtitles():
    whisper_output_dir = Path('whisper_output')
    if not whisper_output_dir.exists():
        logging.error(f'Directory not found: {whisper_output_dir}')
        return None
    srt_files = list(whisper_output_dir.glob('*.srt'))
    if not srt_files:
        logging.warning('No .srt files found in the whisper_output directory.')
        return None
    with open(srt_files[0], 'r') as file:
        subtitles = file.read()
    return subtitles

