# Cluster 4

def get_workflow_by_key(workflow_key):
    """Get a specific workflow by its key"""
    workflows = get_available_workflows()
    return workflows.get(workflow_key, None)

def get_available_workflows():
    """
    Get all available automated workflows.
    All workflows can use any configured tools - no restrictions.
    """
    workflows = {'reconnaissance': {'name': 'Reconnaissance and Discovery', 'description': 'Comprehensive information gathering and target profiling', 'steps': ['Perform comprehensive reconnaissance on {target}', 'Discover subdomains and DNS information', 'Scan for open ports and services', 'Identify technology stack and fingerprints', 'Gather historical data and archived content']}, 'web_application': {'name': 'Web Application Security Assessment', 'description': 'Comprehensive web application penetration testing', 'steps': ['Discover web directories and hidden content on {target}', 'Test for SQL injection vulnerabilities', 'Scan for web application vulnerabilities and misconfigurations', 'Analyze SSL/TLS configuration and security', 'Test for authentication and session management flaws', 'Check for file inclusion and upload vulnerabilities']}, 'network_infrastructure': {'name': 'Network Infrastructure Penetration Test', 'description': 'Network-focused penetration testing and exploitation', 'steps': ['Scan network range {target} for live hosts and services', 'Perform detailed service enumeration and version detection', 'Scan for known vulnerabilities in discovered services', 'Test for network service misconfigurations', 'Attempt exploitation of discovered vulnerabilities', 'Assess network segmentation and access controls']}, 'full_penetration_test': {'name': 'Complete Penetration Test', 'description': 'Full-scope penetration testing methodology', 'steps': ['Phase 1: Quick port scan to identify open services on {target}', 'Phase 2: Service version detection on discovered ports', 'Phase 3: Web service discovery and directory enumeration', 'Phase 4: Focused vulnerability scanning of services', 'Phase 5: Targeted exploitation of discovered vulnerabilities', 'Phase 6: Post-exploitation enumeration if access gained', 'Phase 7: Compile findings and remediation recommendations']}}
    return workflows

def list_workflow_names():
    """Get a list of all workflow names for display"""
    workflows = get_available_workflows()
    return [(key, workflow['name']) for key, workflow in workflows.items()]

class WorkflowEngine:
    """Handles automated workflow execution."""

    def __init__(self):
        """Initialize the workflow engine."""
        self.workflows_available = self._check_workflows_available()

    @staticmethod
    def _check_workflows_available() -> bool:
        """Check if workflow definitions are available."""
        try:
            from workflows.workflow_definitions import get_available_workflows
            return True
        except ImportError:
            return False

    def is_available(self) -> bool:
        """Check if workflows are available."""
        return self.workflows_available

    @staticmethod
    def show_automated_menu() -> Optional[List[tuple]]:
        """Display the automated workflow selection menu."""
        try:
            print(f'\n{Fore.CYAN}WORKFLOWS{Style.RESET_ALL}')
            print(f'{Fore.WHITE}{'=' * 50}{Style.RESET_ALL}')
            workflow_list = list_workflow_names()
            workflows = get_available_workflows()
            for i, (key, name) in enumerate(workflow_list, 1):
                description = workflows[key]['description']
                step_count = len(workflows[key]['steps'])
                print(f'{i}. {Fore.YELLOW}{name}{Style.RESET_ALL}')
                print(f'   {Fore.WHITE}{description}{Style.RESET_ALL}')
                print(f'   {Fore.CYAN}Steps: {step_count}{Style.RESET_ALL}')
                print()
            print(f'{len(workflow_list) + 1}. {Fore.RED}Back to Main Menu{Style.RESET_ALL}')
            return workflow_list
        except Exception:
            print(f'{Fore.YELLOW}Error loading workflows.{Style.RESET_ALL}')
            return None

    async def run_automated_workflow(self, workflow: Dict[str, Any], target: str, connected_servers: List[Any], conversation_history: List[Dict[str, str]], kb_instance: Any, run_agent_func: Any) -> List[Dict[str, Any]]:
        """
        Execute a workflow.
        
        Args:
            workflow: The workflow definition
            target: The target for the workflow
            connected_servers: List of connected MCP servers
            conversation_history: Conversation history list
            kb_instance: Knowledge base instance
            run_agent_func: Function to run agent queries
            
        Returns:
            List of workflow results
        """
        available_tools = MCPManager.get_available_tools(connected_servers)
        print(f'\n{Fore.CYAN}Starting Automated Workflow: {workflow['name']}{Style.RESET_ALL}')
        print(f'{Fore.YELLOW}Target: {target}{Style.RESET_ALL}')
        print(f'{Fore.CYAN}Available Tools: {(', '.join(available_tools) if available_tools else 'None')}{Style.RESET_ALL}')
        print(f'{Fore.WHITE}Description: {workflow['description']}{Style.RESET_ALL}')
        print(f'{Fore.WHITE}{'=' * 60}{Style.RESET_ALL}')
        results = []
        for i, step in enumerate(workflow['steps'], 1):
            print(f'\n{Fore.CYAN}Step {i}/{len(workflow['steps'])}{Style.RESET_ALL}')
            formatted_step = step.format(target=target)
            print(f'{Fore.WHITE}{formatted_step}{Style.RESET_ALL}')
            enhanced_query = f'\nTARGET: {target}\nSTEP: {formatted_step}\n\nExecute this step and provide the results.\n'
            result = await run_agent_func(enhanced_query, connected_servers, history=conversation_history, streaming=True, kb_instance=kb_instance)
            if result and hasattr(result, 'final_output'):
                results.append({'step': i, 'description': formatted_step, 'output': result.final_output})
                conversation_history.append({'user_query': enhanced_query, 'ai_response': result.final_output})
            print(f'{Fore.GREEN}Step {i} completed{Style.RESET_ALL}')
            await asyncio.sleep(1)
        print(f'{Fore.CYAN}Steps executed: {len(results)}/{len(workflow['steps'])}{Style.RESET_ALL}')
        return results

    def get_workflow(self, workflow_key: str) -> Optional[Dict[str, Any]]:
        """Get a workflow by its key."""
        try:
            return get_workflow_by_key(workflow_key)
        except Exception:
            return None

    def get_workflow_list(self) -> List[tuple]:
        """Get list of available workflows."""
        try:
            return list_workflow_names()
        except Exception:
            return []

