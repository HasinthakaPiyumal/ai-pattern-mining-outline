# Cluster 60

class JobSchedulerTests(unittest.TestCase):

    def __init__(self, *args, **kwargs):
        super().__init__(*args, **kwargs)

    def get_dummy_job_catalog_entry(self, active, job_name, next_run):
        return JobCatalogEntry(name=job_name, queries=None, start_time=None, end_time=None, repeat_interval=None, active=active, next_scheduled_run=next_run, created_at=None, updated_at=None)

    def test_sleep_time_calculation(self):
        past_job = self.get_dummy_job_catalog_entry(True, 'past_job', datetime.now() - timedelta(seconds=10))
        future_job = self.get_dummy_job_catalog_entry(True, 'future_job', datetime.now() + timedelta(seconds=20))
        job_scheduler = JobScheduler(MagicMock())
        self.assertEqual(job_scheduler._get_sleep_time(past_job), 0)
        self.assertGreaterEqual(job_scheduler._get_sleep_time(future_job), 10)
        self.assertEqual(job_scheduler._get_sleep_time(None), 30)

    def test_update_next_schedule_run(self):
        future_time = datetime.now() + timedelta(seconds=1000)
        job_scheduler = JobScheduler(MagicMock())
        job_entry = self.get_dummy_job_catalog_entry(True, 'job', datetime.now())
        job_entry.end_time = future_time
        status, next_run = job_scheduler._update_next_schedule_run(job_entry)
        self.assertEqual(status, False, 'status for one time job should be false')
        job_entry.end_time = future_time
        job_entry.repeat_interval = 120
        expected_next_run = datetime.now() + timedelta(seconds=120)
        status, next_run = job_scheduler._update_next_schedule_run(job_entry)
        self.assertEqual(status, True, 'status for recurring time job should be true')
        self.assertGreaterEqual(next_run, expected_next_run)
        job_entry.end_time = datetime.now() + timedelta(seconds=60)
        job_entry.repeat_interval = 120
        expected_next_run = datetime.now() + timedelta(seconds=120)
        status, next_run = job_scheduler._update_next_schedule_run(job_entry)
        self.assertEqual(status, False, 'status for rexpired ecurring time job should be false')
        self.assertLessEqual(next_run, datetime.now())

class JobCatalog(BaseModel):
    """The `JobCatalog` catalog stores information about all the created Jobs.
    `_row_id:` an autogenerated unique identifier.
    `_name:` the job name.
    `_queries:` the queries to run as part of this job
    `_start_time:` the job's start time
    `_end_time:` the job's end time
    `_repeat_interval:` the job's repeat interval
    `_repeat_period:` the job's repeat period
    `_active:` is the job active/deleted
    `_next_scheduled_run:` the next trigger time for the job as per the schedule
    `_created_at:` entry creation time
    `_updated_at:` entry last update time
    """
    __tablename__ = 'job_catalog'
    _name = Column('name', String(100), unique=True)
    _queries = Column('queries', String, nullable=False)
    _start_time = Column('start_time', DateTime, default=datetime.datetime.now)
    _end_time = Column('end_ts', DateTime)
    _repeat_interval = Column('repeat_interval', Integer)
    _active = Column('active', Boolean, default=True)
    _next_scheduled_run = Column('next_scheduled_run', DateTime)
    _created_at = Column('created_at', DateTime, default=datetime.datetime.now)
    _updated_at = Column('updated_at', DateTime, default=datetime.datetime.now, onupdate=datetime.datetime.now)
    _next_run_index = Index('_next_run_index', _next_scheduled_run)
    _job_history_catalog = relationship('JobHistoryCatalog', cascade='all, delete')

    def __init__(self, name: str, queries: str, start_time: datetime, end_time: datetime, repeat_interval: Integer, active: bool, next_schedule_run: datetime):
        self._name = name
        self._queries = queries
        self._start_time = start_time
        self._end_time = end_time
        self._repeat_interval = repeat_interval
        self._active = active
        self._next_scheduled_run = next_schedule_run

    def as_dataclass(self) -> 'JobCatalogEntry':
        return JobCatalogEntry(row_id=self._row_id, name=self._name, queries=json.loads(self._queries), start_time=self._start_time, end_time=self._end_time, repeat_interval=self._repeat_interval, active=self._active, next_scheduled_run=self._next_scheduled_run, created_at=self._created_at, updated_at=self._updated_at)

